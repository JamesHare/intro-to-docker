{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"An Intro to Docker This guide contains an introduction to Docker. I will continue to update as I learn more. Overview of Course Overview of Docker Working with Containers Swarm Mode and Microservices","title":"Home"},{"location":"#an-intro-to-docker","text":"This guide contains an introduction to Docker. I will continue to update as I learn more.","title":"An Intro to Docker"},{"location":"#overview-of-course","text":"","title":"Overview of Course"},{"location":"#overview-of-docker","text":"","title":"Overview of Docker"},{"location":"#working-with-containers","text":"","title":"Working with Containers"},{"location":"#swarm-mode-and-microservices","text":"","title":"Swarm Mode and Microservices"},{"location":"about/","text":"About Author James Hare Email: harejamesm@gmail.com LinkedIn: https://www.linkedin.com/in/jameshareuk GitHub Portfolio: https://github.com/JamesHare","title":"About"},{"location":"about/#about","text":"","title":"About"},{"location":"about/#author","text":"James Hare Email: harejamesm@gmail.com LinkedIn: https://www.linkedin.com/in/jameshareuk GitHub Portfolio: https://github.com/JamesHare","title":"Author"},{"location":"overview-of-docker/coming-soon/","text":"Coming Soon","title":"Overview of Docker"},{"location":"overview-of-docker/coming-soon/#coming-soon","text":"","title":"Coming Soon"},{"location":"swarm-mode-and-microservices/coming-soon/","text":"Coming Soon","title":"Swarm Mode and Microservices"},{"location":"swarm-mode-and-microservices/coming-soon/#coming-soon","text":"","title":"Coming Soon"},{"location":"working-with-containers/basic-docker-commands/","text":"The Basic Docker Commands One of the best things about Docker is that it works the exact same way across all platforms. The idea is that you build once and run anywhere. The first command you should run after installing Docker is the version command: docker version In the output you will see the client and server versions running locally on the machine that you're logged onto. The next command you should run is the docker info command: docker info The output will show how many containers and containers you have (how many are running, paused and stopped), how many images you have, the total number CPUs Docker is using, etc. The next command you should run is the Docker Run command: docker run hello-world Let's break this down a bit further. All Docker commands will start with \"docker\" which calls the Docker binary in the background. \"run\" is the standard way of asking Docker to run a new container. \"hello-world\" is the image that you want Docker to run. After hitting return, the client goes and talks to the deamon. The Daemon will check to see if it has a copy of the hello-world image stored locally. If this is the first time you are running this command, it won't be stored locally yet. So the daemon will go and pull the image from Docker Hub, which I will write about later in this guide. The deamon takes the image from Docker Hub and uses it as a template to create a new container. The hello-world image creates a really simple container with a short message from Docker specifying the steps that you just ran and more about what's going on behind the scenes including what you just read above. After the output is printed to the terminal, the container exits. If we run the \"docker ps\" command, we can see that no containers are currently running: docker ps If we run the \"docker ps -a\" it will show us our hello-world container that was running but has now exited (see the STATUS column of the output): docker ps -a Docker ps is a command that you will use a lot to view your containers that are currently running. If you run the \"docker info\" command again you will see that you have 1 container (in the stopped state) and 1 image downloaded: docker info If you want to see the images that you have on your system, run the \"docker images\" command: docker images In the output of this command you will see the repository of image names, the tag (which corresponds to the version of the image), the image ID, when it was created and the size of the image. So to summarize all the information above, here are the commands we looked at. docker run - to run a new container docker ps - to see running and stopped containers docker images - to see info about images stored locally","title":"Basic Docker Commands"},{"location":"working-with-containers/basic-docker-commands/#the-basic-docker-commands","text":"One of the best things about Docker is that it works the exact same way across all platforms. The idea is that you build once and run anywhere. The first command you should run after installing Docker is the version command: docker version In the output you will see the client and server versions running locally on the machine that you're logged onto. The next command you should run is the docker info command: docker info The output will show how many containers and containers you have (how many are running, paused and stopped), how many images you have, the total number CPUs Docker is using, etc. The next command you should run is the Docker Run command: docker run hello-world Let's break this down a bit further. All Docker commands will start with \"docker\" which calls the Docker binary in the background. \"run\" is the standard way of asking Docker to run a new container. \"hello-world\" is the image that you want Docker to run. After hitting return, the client goes and talks to the deamon. The Daemon will check to see if it has a copy of the hello-world image stored locally. If this is the first time you are running this command, it won't be stored locally yet. So the daemon will go and pull the image from Docker Hub, which I will write about later in this guide. The deamon takes the image from Docker Hub and uses it as a template to create a new container. The hello-world image creates a really simple container with a short message from Docker specifying the steps that you just ran and more about what's going on behind the scenes including what you just read above. After the output is printed to the terminal, the container exits. If we run the \"docker ps\" command, we can see that no containers are currently running: docker ps If we run the \"docker ps -a\" it will show us our hello-world container that was running but has now exited (see the STATUS column of the output): docker ps -a Docker ps is a command that you will use a lot to view your containers that are currently running. If you run the \"docker info\" command again you will see that you have 1 container (in the stopped state) and 1 image downloaded: docker info If you want to see the images that you have on your system, run the \"docker images\" command: docker images In the output of this command you will see the repository of image names, the tag (which corresponds to the version of the image), the image ID, when it was created and the size of the image. So to summarize all the information above, here are the commands we looked at. docker run - to run a new container docker ps - to see running and stopped containers docker images - to see info about images stored locally","title":"The Basic Docker Commands"},{"location":"working-with-containers/container-lifecycle/","text":"The Lifecycle of a Container One thing that people generally worry about when using containerization in their tech stack is persistance. Luckily, Docker containers have the capability to persist data after they have been stopped and started again. In fact, it is not until you run the docker remove command (docker rm) that a container's data gets deleted. Let's look at a more complex command: docker run -d --name web -p 80:8080 [namespace]/[image name] We already know what \"docker run\" does. The -d flag tells the deamon to start the container in detached mode. Meaning that it will run in the background and not attach to the current terminal. If we wanted to interact with the container we could instead use the -it flag and then append /bin/bash to the command to enter the container and interact with it. The --name flag just allows us to name our container. The -p flag tells the deamon which ports to map to. The image, which can be anything, is most likely a web service here since we are using port 8080. The 80:8080 argument tells the daemon to map port 80 on the docker host to 8080 on the container. This means that when we go to access the UI at a URL, we can use port 80. Something different about how I specified the image name here, is that I prepended it with a namespace. An example being jamesmhare/image-name. The reason you may sometimes have to do this is that you may be using what is called a second level image. We have already worked with first level images (these are images that live at the root level on Docker Hub and are maintained by official teams). However, second level images are stored in their own namespace and are generally less-offical images that a user maintains. That means that none of the second level images are really all that trustworthy. They may be less secure and you are really at the mercy of the developer. So let's take a quick look at running a container and interacting with it. As mentioned above, we can use the -it flag instead of the -d flag to interact with the containers when using docker run: docker run -it --name web -p 80:8080 [namespace]/[image name] /bin/bash Remember to append /bin/bash to the end of the command. This tells the daemon to start the container with bash running. You will notice that you command prompt has changed and that you are now inside your running container. You can now run all the commands that you may be familiar with (ls, cd, top, etc.) and execute them in the container. One thing to remember is that you cannot just use the exit command to get out of the container as, since /bin/bash is probably the only process running in the container, if you exit out of your docker run command, you will kill the /bin/bash process and the container will automatically stop because it doesn't have any other processes running. Instead, you should use ctrl + p + q. Cleaning Up Containers At this point, I wanted to introduce some other commands that can be useful in cleaning up running containers. This can be helpful when you have a lot of contianers running and you want to interact with them all. To stop all containers, execute the following command: docker stop $(docker ps -aq) To remove all containers, execute the following command: docker rm $(docker ps -aq) To remove all images, execute the following command: docker rmi $(docker ps -aq) Running these three commands will ensure that you have Docker back to the original state as it was when we first started. It's a good way to wipe the slate clean and start over, if you need to.","title":"Container Lifecycle"},{"location":"working-with-containers/container-lifecycle/#the-lifecycle-of-a-container","text":"One thing that people generally worry about when using containerization in their tech stack is persistance. Luckily, Docker containers have the capability to persist data after they have been stopped and started again. In fact, it is not until you run the docker remove command (docker rm) that a container's data gets deleted. Let's look at a more complex command: docker run -d --name web -p 80:8080 [namespace]/[image name] We already know what \"docker run\" does. The -d flag tells the deamon to start the container in detached mode. Meaning that it will run in the background and not attach to the current terminal. If we wanted to interact with the container we could instead use the -it flag and then append /bin/bash to the command to enter the container and interact with it. The --name flag just allows us to name our container. The -p flag tells the deamon which ports to map to. The image, which can be anything, is most likely a web service here since we are using port 8080. The 80:8080 argument tells the daemon to map port 80 on the docker host to 8080 on the container. This means that when we go to access the UI at a URL, we can use port 80. Something different about how I specified the image name here, is that I prepended it with a namespace. An example being jamesmhare/image-name. The reason you may sometimes have to do this is that you may be using what is called a second level image. We have already worked with first level images (these are images that live at the root level on Docker Hub and are maintained by official teams). However, second level images are stored in their own namespace and are generally less-offical images that a user maintains. That means that none of the second level images are really all that trustworthy. They may be less secure and you are really at the mercy of the developer. So let's take a quick look at running a container and interacting with it. As mentioned above, we can use the -it flag instead of the -d flag to interact with the containers when using docker run: docker run -it --name web -p 80:8080 [namespace]/[image name] /bin/bash Remember to append /bin/bash to the end of the command. This tells the daemon to start the container with bash running. You will notice that you command prompt has changed and that you are now inside your running container. You can now run all the commands that you may be familiar with (ls, cd, top, etc.) and execute them in the container. One thing to remember is that you cannot just use the exit command to get out of the container as, since /bin/bash is probably the only process running in the container, if you exit out of your docker run command, you will kill the /bin/bash process and the container will automatically stop because it doesn't have any other processes running. Instead, you should use ctrl + p + q.","title":"The Lifecycle of a Container"},{"location":"working-with-containers/container-lifecycle/#cleaning-up-containers","text":"At this point, I wanted to introduce some other commands that can be useful in cleaning up running containers. This can be helpful when you have a lot of contianers running and you want to interact with them all. To stop all containers, execute the following command: docker stop $(docker ps -aq) To remove all containers, execute the following command: docker rm $(docker ps -aq) To remove all images, execute the following command: docker rmi $(docker ps -aq) Running these three commands will ensure that you have Docker back to the original state as it was when we first started. It's a good way to wipe the slate clean and start over, if you need to.","title":"Cleaning Up Containers"},{"location":"working-with-containers/pulling-and-running-containers/","text":"Pulling and Running Containers As a quick recap of what we have already looked at in this guide, I wanted to provide more infomration on what is going on behind the scenes when we pull and run containers with Docker. So we have our \"Docker Host\" running the docker client and the docker daemon. That combination is also known as the \"Docker Engine.\" We issue the simple docker run command to the client. The client makes the appropriate API calls to the deamon. Based on the fact that the client is calling the docker deamon APIs, we can then understnad that the docker deamon implements the Docker Remote API. After receiving the API call from the client, the docker deamon checks its local store for the image specified in the docker run command. If it does not exist there, the deamon will go and check Docker Hub for the image. Docker Hub is a docker image registery. It's a place where we can store images that we want to use later for contianers. Docker Hub is the default registery that docker will check and it is available on the public Internet. It should be noted that other registeries exist, including secure on-prem registries plus other public and private offerings from third parties. Once the deamon finds the image, it will pull it down to the local machine and then spin up (start) a container using the image.","title":"Pulling and Running Containers"},{"location":"working-with-containers/pulling-and-running-containers/#pulling-and-running-containers","text":"As a quick recap of what we have already looked at in this guide, I wanted to provide more infomration on what is going on behind the scenes when we pull and run containers with Docker. So we have our \"Docker Host\" running the docker client and the docker daemon. That combination is also known as the \"Docker Engine.\" We issue the simple docker run command to the client. The client makes the appropriate API calls to the deamon. Based on the fact that the client is calling the docker deamon APIs, we can then understnad that the docker deamon implements the Docker Remote API. After receiving the API call from the client, the docker deamon checks its local store for the image specified in the docker run command. If it does not exist there, the deamon will go and check Docker Hub for the image. Docker Hub is a docker image registery. It's a place where we can store images that we want to use later for contianers. Docker Hub is the default registery that docker will check and it is available on the public Internet. It should be noted that other registeries exist, including secure on-prem registries plus other public and private offerings from third parties. Once the deamon finds the image, it will pull it down to the local machine and then spin up (start) a container using the image.","title":"Pulling and Running Containers"},{"location":"working-with-containers/what-is-a-container/","text":"What is a Container? Before containerization became popular in the industry, hypervisors were the go to for running apps. A hypervisor grabs physical resources like CPU, RAM, Storage and networks. It slices them into virtual components. Virtual CPU, Virtual RAM, etc. Then it builds virtual machines out of them. Containerization works a bit differently. Instead of slicing the components into virtual components, Docker (and other container engines) slices up Operating System resources. For instance, they slice up the process namespace, the network stack, the storage stack. Every container gets its own Process ID and it's own root file system. In short, \"hypervisor virtualization\" virtualizes physical server resources to build virtual machines. Container Engines like Docker use Operating System virtualization. They create virtual Operating Systems and assign one to each container, inside of which we run applications. They are a lot more lightweight than VM's.","title":"What is a Container?"},{"location":"working-with-containers/what-is-a-container/#what-is-a-container","text":"Before containerization became popular in the industry, hypervisors were the go to for running apps. A hypervisor grabs physical resources like CPU, RAM, Storage and networks. It slices them into virtual components. Virtual CPU, Virtual RAM, etc. Then it builds virtual machines out of them. Containerization works a bit differently. Instead of slicing the components into virtual components, Docker (and other container engines) slices up Operating System resources. For instance, they slice up the process namespace, the network stack, the storage stack. Every container gets its own Process ID and it's own root file system. In short, \"hypervisor virtualization\" virtualizes physical server resources to build virtual machines. Container Engines like Docker use Operating System virtualization. They create virtual Operating Systems and assign one to each container, inside of which we run applications. They are a lot more lightweight than VM's.","title":"What is a Container?"},{"location":"working-with-containers/working-with-images/","text":"Working with Images So now we know how the docker run command works and how containers are based off of images. If you are still confused at this point, think of it this way: Images are stopped Containers Containers are running Images We already know that docker run [image name] will pull down and start a new container using the image name specified. However, we can just pull down an image without running it by using the following command: docker pull [image name] To pull a specific image version we can include the version in the docker pull command as follows: docker pull [image name]:[version] If we don't specify the image version, Docker will just pull the latest release. Remember, you can run the docker images command to list all images that you have downloaded to your local machine: docker images You should take some time to get familiar with Docker Hub. I won't include much info on that here, but head over to https://hub.docker.com and take a look around. Get familiar with the UI. Remember that official images are labeled and are maintained by the teams that built the images and that they often document known security vulnerabilities on older images. Finally, let's look at removing local images. You can remove any image that you have downloaded locally by using the following command: docker rmi [image name] Remember, you can also include the version number if you want to remove that particular image.","title":"Working with Images"},{"location":"working-with-containers/working-with-images/#working-with-images","text":"So now we know how the docker run command works and how containers are based off of images. If you are still confused at this point, think of it this way: Images are stopped Containers Containers are running Images We already know that docker run [image name] will pull down and start a new container using the image name specified. However, we can just pull down an image without running it by using the following command: docker pull [image name] To pull a specific image version we can include the version in the docker pull command as follows: docker pull [image name]:[version] If we don't specify the image version, Docker will just pull the latest release. Remember, you can run the docker images command to list all images that you have downloaded to your local machine: docker images You should take some time to get familiar with Docker Hub. I won't include much info on that here, but head over to https://hub.docker.com and take a look around. Get familiar with the UI. Remember that official images are labeled and are maintained by the teams that built the images and that they often document known security vulnerabilities on older images. Finally, let's look at removing local images. You can remove any image that you have downloaded locally by using the following command: docker rmi [image name] Remember, you can also include the version number if you want to remove that particular image.","title":"Working with Images"}]}